# 23.02.28 TIL
## Today Learned

### 김영한 Spring 기본편 마지막강의 !

빈 스코프 ? 

싱글톤은 빈이 컨테이너가 시작과 함께 생성되고 종료가 되면 같이 종료가 됐었다.  이것은 싱글톤 스코프로 존재했기 때문이라 말할 수 있다.
스코프란 빈이 존재할 수 있는 범위를 말한다. 앞에서 말한 저것은 싱글톤 스코프라 말할 수 있다.

스코프는 두 가지로 일단 나뉜다. 싱글톤 스코프와 프로토타입 스코프.

싱글톤 스코프는 여태 봐왔듯이 컨테이너가 생성되면 같이 올라가고 종료되면 같이 내려가는 식이지만 프로토타입 스코프는 다르다.
싱글톤에 비해 생명주기가 굉장히 짧은데,  프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 나머지는 관리하지 않는다.

그 다음 웹에서의 스코프(request, session, application)가 있지만 이것은 아직 웹에 대한 기술이 많이 부족하기에 일단 프로토타입 스코프에 대해 작성한다.

지금까지 싱글톤은 컨테이너에 빈을 요청하면 하나의 빈으로 재활용해가는 식이었지만, 프로토타입 빈은 다르다. 각각의 빈이 생성되어 필요한 의존관계를 주입한다.
그리고 그에 대한 return을 한 후에 컨테이너는 더이상 관리하지 않는다. (생명주기 끝)

프로토타입은, 컨테이너는 프로토타입 빈을 생성하고 의존관계 주입하며 초기화까지만 처리한다는 것. 그리고 프로토타입은 싱글톤과는 다르게 destroy 메서드는 호출되지 않는다.
관리를 아예 넘겨서인지 나타나지 않음. 그래서 종료 메서드 호출을 하고 싶다면 직접 구현하여 처리해야한다.

여기까지 보면 쉽게 이해할 수 있지만 싱글톤과 프로토타입 빈을 함께할 때가 문제다.  프로토타입은 위에서 이야기했듯이 각각의 빈이 생성되어 반환이 되는데,
1을 더하는 메서드를 사용하는데 두 번 생성할 경우 2가 아닌 1 1이 된다는 것. 여기서 싱글톤을 함께 사용하면 나는 1 1 의 값을 기대했지만

싱글톤은 컨테이너가 올라가면 같이 띄워짐과 동시에 재활용을 한다 하지 않았던가 ?  프로토타입이 같이 쓰이게 되면 사라지지 않고 계속 남아있게 된다.

그래서 두 번 호출(생성)하게되면 1 1이 아닌 값이 2가 나와버림. 물론 사용할 때마다 새로 생성되는 것은 아니다. 그래서 이에 대한 해결방법은 많이 있다.

직관적이면서 가장 쉬웠던 방법은 그냥 사용할 때마다 컨테이너에게 새로 요청하는 것. 하지만 이것은 그리 좋지 않은 방법이었다. **그렇게 되면 컨테이너에 종속적이며 단위테스트도 힘들어진다는 것.**


그래서 ObjectProvider(ObjectFactory)가 있다. Factory는 예전에 쓰이던 거고 요즘은 Provider를 쓰는데, Factory를 상속하며, 여러 편의 기능들이 많으며
별도의 라이브러리가 필요없다.

마지막으로 JSR-330 provider방법인데, 이를 사용하려면 라이브러리를 따로 추가해야한다. javax에서 사용.

다른 코드도 없고 그냥 .get() 메서드로 의존관계 조회(DL)가 가능하다. javax이기에 스프링이 아닌 다른 곳에서도 사용이 가능하다는 것이 특징이다.

마지막으로 웹 스코프에 대해서도 공부했는데, 이런 게 있구나라는 정도로만 일단 들었다. 짧게 특징과 종류들을 작성해놓자.

웹 스코프 특징?
* 웹 환경에서만 동작함.
* 프로토타입과는 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. -> 종료메서드 호출함.

웹 스코프 종류?
* request : HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 인스턴스 생성, 관리
* session : HTTP Session과 동일한 생명주기를 가짐
* application : 서플릿 컨텍스트(ServletContext)와 동일한 생명주기를 가짐
* websocket : 웹 소켓과 동일한 생명주기를 가짐.

서로 비슷비슷하기에 request 정도만 알아도 다 유추 가능. 웹 기술에 관해 공부하게 되면 다시 찾아와서 공부를 더 해보자.


###  G.C에 대해...
Garbage Collection에 대해 공부를 시작하려 한다. 이는 우선적으로 저번에 study에서 한 번 다뤘던 내용이었지만 따로 공부해서 이해하고 싶기에
다시 따로 공부를 해야겠다. 우선 이론적인 부분부터 공부를 해서 차근차근 알아가보는 식으로 해보자.

Garbage Collection을 알아보기 전, 알고 넘어가야 할 것이 있는데 그것은 'stop-the-world'라는 것이다. 

stop-the-world는 무엇인가 ?GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것. 이것이 발생하면 GC를 실행하는 Thread를 제외한
나머지 Thread는 작업을 멈춘다. 해당 GC의 작업이 끝나야 다시 시작한다. 어떤 GC 알고리즘을 사용한들, **stop-the-world는 무조건 발생한다.**

Java는 메모리를 명시적으로 지정하여 해제하지 않는다 한다.  그것을 해제하려고 System.gc() 메서드를 사용할..수는 있는데 이는 시스템의 성능에 매우 큰 영향을 끼칠 수 있으니
절대 사용하지 말 것.

아무튼 명시적으로 지정하여 해제하지 않아 GC가 이를 작업해 사용하지 않는, 필요없는 객체를 찾아서 지우는 작업을 한다. 그럼 이 필요없는 객체의 선정 기준은 무엇일까?
그리고 JVM과 연관이 있는데 무엇일지..?

JVM의 메모리에 총 5가지 영역(java application을 실행할 때 사용되는 데이터들을 적재하는 영역)으로, 클래스, 스택, 힙, 네이티브 메서드, PC로 나뉘는데 이는 힙 메모리만 다룬다.

여기 heap 영역에서 각각의 영역이 있음. Eden, survivor1, suvivor2, Old, Permanent Generation(이것은 heap이 아님. JVM에 의해 사용하는 클래스와 메서드 객체 정보를 담고 있음. Java 8 이후 Metaspace로 변경)

**이 코드 상에서 어떤 대상이 GC가 될까?** 

* 객체가 null인 경우 (String str = null)
* 블럭 안에서 생성된 객체는 블럭 실행 종료 후 대상이 됨. (for문 안의 객체?)
* 부모 객체가 null이 되면, 포함하는 자식 객체들도 자동으로 GC의 대상이 됨.

Heap 영역을 그럼 알아보자. 이 영역의 구조로 크게 두 가지로 영역이 나뉘는데, young, old로 나뉜다.

1.Young Generation ?
* 객체 사용 시간이 짧음. 
* 영역의 종류 ? **Eden, survivor1, 2 
* 새롭게 생성한 객체는 먼저 Young Generation에 위치함.
* 많은 객체가 이 영역에 생성되었다 사라진다.
* 이 영역에서 사라지게 되면 Minor GC가 발생했다고 말한다.


2.Old Generation ?
* ***Tenured 및 가상 공간을 포함.
* Young 영역에서 살아남은 객체가 이곳으로 복사
* Young 영역보다 메모리가 크게 할당되어서 Young 영역보다 GC가 덜 발생함.
* 이 영역에서 사라지게 되면 Major GC(Full GC)가 발생했다고 말한다.


** Eden, survivor ? 

1. Eden ? 대부분의 객체에 대해 초기 메모리가 할당되는 pool
2. Survivor ? Eden 공간의 GC에서 살아남은 객체를 포함하는 pool

***Tenured ? 이 메모리 pool에는 여러 GC 후 살아남은 객체가 포함이 됨. Young의 Survivor 영역에서 GC이후 살아남은 객체가 이곳에 있음.


여기까지 정리하고 다음날에 이어서 공부하자. 그리고 따로 JVM에 대해 더 깊이 공부해야될 거 같다.

REF 🙇‍♂️

좋은 GC글을 써 주셔서 감사합니다. [Java Garbage Collection](https://d2.naver.com/helloworld/1329) 조금 더 알아보면서 공부하겠습니다. 
[Heap 영역 내](https://stackoverflow.com/questions/2129044/java-heap-terminology-young-old-and-permanent-generations)




## 느낀점 ?
늘 느꼈던 것도 있지만 프로젝트하면서도 더 느끼는 건.. 패키지명과 해당 패키지내의 클래스들.. 어떻게 잘 분류해서 넣는가 ?
이것이 정말 어려운 문제라고 본다. 이것을 잘 분류해서 누구나 알아보기 쉽게 각각의 알맞는 기능을 넣는다는 것은.... 아무리봐도 어렵다..ㅜㅜ
혼자 직접 만들어 보는 프로젝트가 처음이라 그런 건지는 몰라도 굉장히 고민할 것이 많으며, 구현만이 답이 아니라는 것을 뼈저리게 느낀다.

기본적인 CRUD는 구현했다지만.. 다시 몇 개의 메서드나..클래스를 수정해서 Repository package 로 옮긴다던지 해야겠다. 알려준 내 스터디 멤버에게 감사인사를!! 🙇‍♂️

기본편이 다 끝나서 좋기도 하지만 너무 미뤄져서 (다른 일들로 인해..) 아쉬웠다. 그래도 무사히 마쳤다는 사실에 기뻐해야하나. 다음으로는 HTTP 강의를 수강할 예정이다.

## 내일 할 일 ?
GC, Spring, 프로젝트...