# 23.01.30 TIL
## Today Learned
### ✍️Spring

DB 과제를 끝마치면서 곧바로 Spring을 시작한다. 우선 Spring을 본격적으로 들어가기에 앞서 OOP란 무엇인지
알아보고 들어가야 한다 ! 해당 내용은 공부하면서 메모장에 적어둔 것을 그대로 기재한 것이다.

## OOP와 스프링 프레임 워크의 관계 ?

OOP ? - 객체지향형 프로그램
실무 코드의 복잡도는 엄청남.. 그래서 어떻게 설계를 해야하나? 우리가 원하는 기능이 어디에 있는지
더 빨리 파악하고 우리가 불필요한, 잘못된 것을 고치는 거.. 방법론이 곧 OOP..

이 OOP를 편리하고 빠르게 코딩할 수 있도록 하는 것이 스프링 프레임 워크이다.

### 객체지향은 대체 무엇이고, 왜 해야하고, 무엇이 필요한지..?

스프링 이론과 그것을 이용한 실전-!!

📌Library와 FrameWork의 차이점 ?

lib 은 내 코드가 lib을 부르는 형식이지만 F.W는 F.W가 내 코드를 부르는 형식임..
그럼 F.W은 내 코드를 어떻게 호출(사용)할까 ? <- 이것만 알아도 쓸 수 있음. !! 근데 F.W 의 전체를 이해하기에는 어렵다..(불가능임)

내가 알아야 되는 부분을 포커싱해서 알아야 하고, 그 외는 그때그때 필요할 때마다 알아보는 정도로 공부하는 것이 좋음

---

## OOP (객체지향 프로그래밍)을 왜 해야할까? spring 과는 어떤 관계가 있을까 ?

Class 의 역할...
- 프로그램의 코드를 체계적으로 분류
- 같은 역할을 하는 코드를 응집성 있게 모아준다.

OOP에서 중요한 것은 분류와 교체 !

그 중 교체.. 어려운 이유가 무엇인가 ?

1. 너무 복잡하게 기능이 섞여 있어서 어디를 어떻게 고쳐야할지 파악이 어려움.
2. 기능 추가 후에 기존에 잘 돌던 기능들이 갑자기 동작x
3. 내가 고친 곳과 상관 없는 전혀 엉뚱한 곳이 갑자기 잘못 동작함.


그래서 객체 지향 프로그래밍을 해야한다. 객체지향프로그래밍이란?

데이터(상태, Field)와 로직(행위, Method)이 응집되어 상호 교류하며 동작하도록 만드는 프로그래밍 기법이다.


---

# OOP 잘하는 방법 !  ( 중요 :  분류, 교체 )



## SOLID ?

* S: SRP (단일 책임 원칙) [분류] Single Responsibility Principle -> **" 한 클래스는 단일의 책임만 가져야 한다. "** 
클래스를 나누어서 비슷한 것들끼리 묶어버림
* 
  = 컨플릭을 방지, 역할에 해당하는 서비스를 잘 찾는다.


* O: OCP (개방 폐쇄 원칙) [교체] Open/Close Principle -> **" 확장에는 열려있고, 변경에는 닫혀있다. "**  원래 있는 기능은 그대로 두되,
  영역을 확장해 나가면서 기능을 추가한다.
* 
  = if else 에서 반복적인 케이스가 보이면, 클래스 분리를 고려


* L: LSP (리스코프 치환 법칙) [교체]  LisKov Substitution Principle -> " 서브타입은 언제나 기반타입으로 교체할 수 있어야 한다. "
  교체를 어떻게 쉽게 할 수 있을까..? (치환)
  -> 상속받은 클래스는 부모 클래스와 동일한 동작을 해야 재활용 가능성이 높아진다.
  (부모타입을 인터페이스처럼 생각한다.) + (중요!!) 기능을 너무 확장하거나 변경하면 재활용성이 낮아짐.
  ex) 자동차 클래스(부모) -> 오픈카(o), 경찰차(o), 헬리콥터(x) 이런 예시임..

상속의 대안 or 상속을 잘하는 방법?
1. 상속을 위한 설계를 한 클래스만 상속할 것
2. 부모 클래스 상속 대신 인터페이스를 활용할 것
3. 피할 수 없다면 상속을 하지만 부모와 상호 치환이 가능하도록 할 것. -> 부모 클래스와 동일한 기능 제공
* = 상속보다는 if를 고려하고, 상속을 해도 비슷하게 만들어야 교체가 쉽다.

<br>

* I: ISP (인터페이스 분리 원칙) [분류] Interface Segregation Principle -> " interface도 단일 책임을 갖도록 분리해야 한다. "
  -> SRP (단일 책임 원칙) 와 다소 유사하지만 인터페이스도 단일의 책임을 갖도록 설계해야 필요한 기능만
  구현하고 제공할 수 있다.

  너무 큰 인터페이스를 만들면 빈 메서드를 만드는 경우가 발생해버림.
* = 인터페이스도 OCP를 따라야 구현이 편리하고 재활용성 올라간다.


* D: DIP (의존성 역전 원칙) [교체] Dependency Inversion Principle -> " 하위 모듈의 변경이 상위 모듈의 변경을 요구하는 의존성을 끊어내야 한다. "
  -> 개발을 하다 보면 내가 사용하던 라이브러리를 다른 라이브러리로 변경하면 코드를 다 뜯어 고쳐야 하는 경우가
  있는데 그렇게 라이브러리에 직접적으로 의존하면 교체가 어려움.

* = 하위 모듈에 너무 의존하면 변경이 어려움, 중간 if 를 둬야 하위 모듈 변경이 쉽다.


--- 

## 개발하면서 상기할 것.. (+느낀점!) 

KISS (Kepp It Simple Stupid ! ) 그냥 단순하게 생각하고..그렇게 해

YAGNI (You Ain't Gonna Need it ) 너 생각보다 필요하지 않다. (불필요한 것들은 과감하게 지워버려! )

SOLID는 중요하지만... 처음부터 (지금 시기, 주니어) 억지로 적용하려고 하면 더더욱 코드는 꼬이고 어려워지기 마련.
시스템이 성장하면서 내 개발 실력도 같이 올라갈 때 그때 SOLID를 한번씩 생각해보자.

객체지향은 정말 어려운 거 같다. 수도없이 생각하고 잘 짜여진 코드를 보면서 배우는 것이 가장 중요해 보인다.(틀릴 수도 있음)
아무래도 정답이 없기에... 책을 많이 읽어보면 되려나? 경험이 중요하지 않을까 싶다.


## 내일 할 일?
내일도 Spring 계속해서 공부할 예정이다. 내일은 아마 오직 Java만을 이용하여 하나의 Spring 구현해내는 실습을 할 것이다..
무한 삽질은 나중의 디딤돌이 되겠지~ 물론 의미 있는 삽질이어야겠지만-!!!!!


