# 23.03.02 TIL
## Today Learned

## MVC 강의 Servlet과 JSP

Servlet과 jsp를 모두 강의를 통해 알아보았는데, 나의 생각과는 다르게 servlet은 너무나도 불편했다.

마냥 그냥 자바 안의 html 코드라길래 금방 칠 줄 알았더니 코드의 길이수가 기하급수적으로 늘어남과 동시에 실수하면 어디서 틀린지도 확인이 안 된다.
게다가 따로 줄바꿈도 계속해서 추가해줘야해서 페이지 소스보기도 신경쓸 것이 되게 많았다.

jsp는 이를 보완해줬지만, jsp 안에 java 코드를 직접 넣는 형식이었다. 이는 서블릿을 사용할 때보다 훨씬 편하게 느껴졌으며 서블릿의 단점을 보완해주는 형식이었다.
JAVA 안에서 불편하게 일일이 HTML코드를 치지 않아도 됐으며, 보다 더 직관적이게 됐다는 것이다.

하지만 이것에도 단점은 존재했다. jsp의 파일도 같이 무거워질 뿐만 아니라 비지니스 로직이 같이 담겨 있어서 jsp는 view의 역할만,
controller에는 비지니스로직만 들어가게 해야하는 것이다. 이를 왜 그렇게 해야하냐면 view를 간단하게 수정만 하고 싶어도

해당 비지니스 로직을 건들 가능성이 되게 높고, 비지니스 로직이 눈에 보인다는 것이다. view는 view의 역할에만 충실해야한다는 것.

그래서 servlet과 jsp를 혼합하여 같이 사용하면 이것들의 문제를 곧바로 해결할 수 있었다. controller를 통해 model에 parameter 값으로 받았던 것을
담고, 그 담은 데이터들을 viewPath에 담아 그대로 view에 보내면 되는 것이다.

핵심로직은 servlet (HttpServletRequest를 model로 하고, request가 제공하는) setAttribute() 를 사용하면 request 객체에 데이터를 보관하는 것.

이 setAttribute()에는 내장되어있는 함수로 key, value가 있는데 request.setAttribute("key", value)인 식이다.

그럼 저 key 는 곧 jsp에 쓰여질 변수로 지정되는 거고, value는 그 key에 따른 값이다.

그리고 신기했던 건, WEB-INF 였는데, WEB-INF 파일안에 jsp는 외부에서 바로 호출할 수 없었다는 것이다. WAS 에서 정한 룰이라는데 실제로 보니 에러가 나와서
신기했다.

문자열 형식으로 만든 url 값을 객체로 지정해 getRequestDispatcher(지정한 값)이라는 함수를 사용해서 forward(request, response)로 보내준다.
이의 방식은 서버 내부에서 호출되는 방식인데, 약간 이해하기가 어려웠다. 일단은 이렇게 있다는 거를 알고 있으면 될 거 같다.

그래서 이런 규칙들이 곧 MVC 패턴이 되어갔는데, 어느정도 반복이 되다 보니 반복숙달이라는 게 있지 않던가 ? MVC에 관해 어느정도 감이 잡힐 찰나
중복되는 코드들이 눈에 보임과 동시에 강의에서도 뭔가 자꾸 중복되지 않느냐~ 라는 말씀이 있었다. 이것이 한계점이었는데, 이 한계점에 관해선
다음에 알아보도록 하자.

++ servlet만을 이용해서 프로젝트를 할까도 했었지만.. html을 only java코드로 모두 칠 자신이 없다...........


## GC (Heap - Area)
Heap - Area 은 GC의 대상이 되기에 알아보자. (Stack, Method 영역도 GC의 대상임.)

여태 계속 말했었지만 Heap 영역은 몇 가지로 나뉘었다. eden, survivor1, 2, old, permanent(non-heap임.)

나눈 이유는 간단하다. GC가 효율적으로 일어나게 하기 위함.

GC는 두 가지로 나뉘는데,

### Minor GC
* new 영역에서 일어나는 GC이다.

최초에 객체가 생성되면 Eden 영역에 생성된다. 이 영역에 객체가 가득차게 되면 첫 번째 GC가 일어난다.
survivor1 영역에 Eden영역의 메모리를 그대로 복사한다. 그리고 survivor1 영역을 제외한 다른 영역의 객체를 제거한다.

Eden 영역도 가득차고 survivor1 영역도 가득차게 된다면, Eden영역에 생성된 객체과 survivor1영역에 생성된 객체 중에 참조되고 있는 객체가 있는지 검사한다. 만약 되고 있지 않는 객체가 있다면 그 객체는 
내버려 두고 참조되고 있는 객체만 survivor2에 복사된다.

survivor2외에 다른 영역의 객체들을 제거한다.

**이 과정 중에 일정 횟수이상 참조되고 있는 객체들을 survivor2에서 Old 영역으로 이동시킨다. (이 과정들을 반복해서 survivor2영역까지 꽉차기 전에 old로 비운다.)**

### Major GC(Full GC)
* Old 영역에 있는 모든 객체들을 검사하며 참조되고 있는지 확인한다.
* 참조되지 않은 객체들을 모아 한 번에 제거한다.

++Minor GC보다 시간이 훨씬 많이 걸리고, 실행 중에  GC를 제외한 모든 Thread가 중지한다.

📌Major GC가 일어나게 되면?

Old 영역에 있는 참조가 없는 객체들을 표시하고 그 해당 객체들을 모두 제거하게 된다.

그러면서 Heap 메모리 영역에 중간중간 구멍(제거되고 빈 메모리 공간)이 생기는데, 이 부분을 없애기 위해 재구성을 하게 됨.(메모리 정리)

**따라서 메모리를 옮기고 있는데 다른 Thread가 메모리를 사용해버리면 안되기 때문에 모든 Thread가 정지상태가 되는 것.**

[REF](https://coding-factory.tistory.com/829)🙇‍♂️
다음 주제로는 **JMX**에 관해 공부해보자. (물론 너무 깊이있게는 힘들겠으나, 어느정도로 알아보겠다는 것.)

## 프로젝트(~ ing)

해당 프로젝트는 servlet과 jsp 강의부분까지만 듣고 다시 손 볼 예정이다. (강의가 너무 재밌음) 강의를 들으면서 어떻게 구현할지 
계속 생각해보자. 우선은 회원가입과 조회기능이 가장 우선이 되겠다. 가입을 하면 DB에 넣어지고, 웹에서는 가입 성공 메시지와 함께 
로그인하라는 로직 호출 -> 로그인 성공 시 로그인이 된 화면에 넘어가게 되고, '내정보보기'를 누르게 되면 나의 정보들을 볼 수 있는 화면을 만들고 싶다.

우선 로그인이 되어 있는 상태다 보니 계속 들었던 'Session'에 대해 알 필요가 있어 보임. 로그인이 되어 있는 상태에서 
'내정보보기'를 누르면 나의 정보가 다시 parameter로 들어가서 로그인한 그 db정보가 보이도록 하는 것이 핵심이겠다.

어떻게 만들지 생각 좀 많이 해봐야지..


## OS (메모리 관리)

메모리 구조는 1B의 크기로 나뉜다. 그렇게 나뉜 구역은 각 메모리 주소로 구분되는데, 0번지부터 시작한다.
CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)를 사용한다.

시분할 시스템에서, OS를 포함한 모든 응용 프로그램이 메모리에 올라와 실행되기 때문에 메모리의 관리가 복잡해진다.  이 메모리 관리는
메모리 관리 시스템이 따로 관리를 해준다.

메모리 관리자는 해당 메모리에 공간이 부족하거나 한다면 배치를 하던, 재배치를 하던 해당 프로세스를 옮겨준다. 하지만 이렇게 공간이 작아졌다 커졌다하는 반복의 작업들은
매우 복잡한 일이다. 

### 언어

기계어와 어셈블리어는 컴퓨터의 동작을 직접적으로 표현한 언어이다. 저급언어라고도 표현함. 또한, 우리가 사용하는 이 자바라는 언어는 고급언어에 속한다.
사용자가 이해하기 쉽게 프로그래밍할 수 있는 언어이다.

언어 번역 프로그램은, 사용자의 언어를 기계어로 변환해주는 프로그램이다. 자바로 작성한 코드가 컴퓨터가 읽을 수 있게 저급 언어로 변경하여 준다는 것이다.

이것에는 두 가지가 있는데, 컴파일러와 인터프리터가 있다.

1. 컴파일러 ?
* 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역 -> 한꺼번에 실행함. (Java, C...)
2. 인터프리터 ?
* 소스코드를 한 줄씩 번역하여 실행 -> J.S, Basic...

### 컴파일러의 목적 ?

컴파일러의 목적으로는 크게 두 가지가 있다.

1. 오류찾기
* 코드에서 오류를 발견하여 실행 시 문제가 없도록 하는 것이다.
2. 최적화
* 코드를 실행하기 전 코드를 점검하여 오류를 수정하고, 최적화를 해서 보다 더 작고 빠른 실행할 수 있게끔 한다.

이 둘의 차이점이 있는데, 인터프리터는 실행을 한 줄씩 보면서 실행하기에 쓸데 없는 변수라던지 반복하는 것들을 사전에 잡지 못한다. 허나
컴파일러는 미리 사전에 오류를 찾고 쓸데 없는 부분을 없애버릴 수 있기에 이 둘의 차이점은 여기서 찾을 수 있다.

**따라서 컴파일러는 규모가 큰 프로그램에서 사용하는 것이 좋으며, 인터프리터는 간단한 프로그램에서 사용하는 것이 좋다.**

### 메모리 관리자 ?

메모리 관리자는 3가지의 일을 하는데, 가져오기, 배치, 재배치가 있다.
1. 가져오기
* 프로세스가 필요한 데이터를 언제 메모리로 가져올지 결정함.
2. 배치
* 가져온 프로세스를 메모리의 어떤 위치에 놓을지 결정함. **같은 메모리 크기로 잘라내는 것을 '페이징'이라 하며, 프로세스의 크기에 맞게 잘라내는 것을 '세그먼테이션'이라고 한다. 이는 한정된 메모리를 보다 효율적으로 사용하기 위해 만들어진 기준이다.**
3. 재배치
* 메모리가 꽉 차게 되면 어떤 프로세스를 내보낼지 결정함. 앞으로 사용하지 않을 프로세스를 찾아서 내보내는 알고리즘을 '교체 알고리즘'이라 한다.
## 느낀점 ?

프로젝트를 다시 해야해서 이전에 했던 설정이라던지 이런 것들이 조금 많이 아쉽긴 했으나.. 경험이라 생각하고 조금 다시 강의를 들으면서 생각 좀 해보고
만들 예정이다. 그리고 강의를 들으면서 들었던 생각이지만, 과제로 제출했던 프로젝트를 스프링으로 변형해서 한번 더 프로젝트를 따로 만들어볼까도 생각 중이다.

잘 될지는 모르겠으나.. 시도라도 해보려고 한다

## 내일 할 일 ?

MVC, JMX, 알고리즘(03.02일자 했으나 따로 repository를 만들까 생각 중)...